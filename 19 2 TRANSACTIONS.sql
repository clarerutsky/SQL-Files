
-- ITEM 1:	EXAMPLES FOR AUTOCOMMIT TRANSACTIONS : MEANS AUTO SAVE.  	
CREATE DATABASE bankdb

use bankdb

create table tblAccounts			-- Either complete table is created or nothing at all. 
(
AccountID int,
Accbal float,
AccStatus int
)

INSERT INTO tblAccounts VALUES ('10001', 6969621, 1)			--	THIS IS ONE TRANSACTION
INSERT INTO tblAccounts VALUES ('10002', 2346372, 1)			--	THIS IS ONE TRANSACTION



-- ITEM 2:	EXAMPLES FOR EXPLICIT TRANSACTIONS: MANUAL START, MANUAL END
BEGIN TRANSACTION T1									-- THIS STATEMENT IS USED TO START THE TRANSACTION
INSERT INTO tblAccounts VALUES ('10003', 6969621, 1)
INSERT INTO tblAccounts VALUES ('10004', 2346372,  1)
DECLARE @RWCOUNT_VARIABLE INT							-- VARIABLE : A TEMPORARY PLACEHOLDER TO STORE ANY DATA IN MEMORY. FOR COMPUTATIONS.
SELECT @RWCOUNT_VARIABLE = COUNT(*) FROM  tblAccounts	-- THIS IS TO ASSIGN THE ROW COUNT TO A VARIABLE
IF @RWCOUNT_VARIABLE <= 100
	COMMIT												-- TO END THE TRANSACTION: SAVE THE DATA CHANGES 
ELSE 
	ROLLBACK											-- TO END THE TRANSACTION: UNDO THE DATA CHANGES.



	 
 -- ITEM 3:	EXAMPLES FOR IMPLICIT TRANSACTIONS: AUTO START,	MANUAL END
SET IMPLICIT_TRANSACTIONS ON							-- THIS WILL ENABLE IMPLICIT TRANSACTIONS


INSERT INTO tblAccounts VALUES ('20001', 6969621, 1)
INSERT INTO tblAccounts VALUES ('20002', 2346372,  1)
DECLARE @RWCOUNT_VARIABLE INT							-- VARIABLE : A TEMPORARY PLACEHOLDER FOR DATA IN MEMORY.
SELECT @RWCOUNT_VARIABLE = COUNT(*) FROM  tblAccounts	-- THIS IS TO ASSIGN THE ROW COUNT TO A VARIABLE
IF @RWCOUNT_VARIABLE <= 100
	COMMIT												-- TO END THE TRANSACTION: SAVE THE DATA CHANGES 
ELSE 
	ROLLBACK											-- TO END THE TRANSACTION: UNDO THE DATA CHANGES.

SET IMPLICIT_TRANSACTIONS OFF	

-- REALTIME USE OF TRANSACTIONS:
-- ASSUME A BANK TRANSACTION. EITHER DEBIT AND CREDIT ARE SUCCESSFUL OR NOTHING AT ALL. 
-- MEANS : IF CREDIT FAILS THEN DEBIT SHOULD BE "ROLLED BACK"

-- TRANSACTIONS ARE USED FOR DML OPERATIONS IN OLTP ENVIRONMENTS. 


-- ITEM #4:	OPEN TRANSACTIONS  : SUCH TRANSACTIONS THAT ARE STARTED BUT NOT COMMTTED OR ROLLEDBACK
BEGIN TRANSACTION T2
INSERT INTO tblAccounts VALUES ('30001', 6969621, 1)
INSERT INTO tblAccounts VALUES ('30002', 2346372,  1)  

/*
TO TEST THE OPEN TRANSACTION IMPACT:
FROM SSMS : GO TO FILE > NEW  > QUERY WITH CURRENT CONNECTION > RUN BELOW QUERY:
SELECT * FROM tblAccounts							-- THIS QUERY RUNS FORVER. MEANS, QUERY IS BLOCKED. REASON : OPEN TRANSACTIONS.

-- GO TO TOP : QUERY MENU > CANCEL. 

-- TO AVOID QUERY BLOCKING: USE "LOCK HINTS"
SELECT * FROM tblAccounts WITH (NOLOCK)				-- OLD COMMITTED DATA ++ RECENT UNCOMITTED DATA [DIRTY READS OR BAD DATA]
SELECT * FROM tblAccounts WITH (READPAST)			-- OLD COMMITTED DATA

*/

-- TO RESOLVE QUERY BLOCKING:
COMMIT

 
/*
REAL-WORLD USE OF TRANSACTIONS:		CONSIDER A BANKING ENVIRONMENT. DEBITS FROM ONE ACCOUNT, CREDITS TO ANOTHER ACCOUNT. 
IF CREDIT FAILS, THEN DEBIT SHOULD BE ROLLEDBACK. THIS IS POSSIBLE ONLY BY IMPLEMNTING EXPLICIT TRANSACTIONS MECHANISM. 
*/

-- FINAL VERSION OF TSQL QUERY:  JOINS + GROUP BY  + FUNCTIONS + TRANSACTIONS @ LOCK HINTS
CREATE VIEW VIEW_SALES_REPORT 
AS
SELECT T.YEAR, T.QUARTER, SUBSTRING (T.MONTH, 1, 3) AS MONTH, CONVERT (VARCHAR(30), T.DAY, 104) AS SALEDATE,
PRODUCTS_DATA.ProductName, SUM(S.SaleAmount) AS TOTAL_SALES FROM TIME_DATA AS T WITH (READPAST)
INNER JOIN SALES_DATA  AS S WITH (READPAST)
ON T.TimeKey = S.TimeKey 
INNER JOIN PRODUCTS_DATA  WITH (READPAST)
ON PRODUCTS_DATA.ProductKey = S.ProductKey 
GROUP BY T.YEAR, T.QUARTER, T.MONTH, T.DAY, PRODUCTS_DATA.ProductName
HAVING	SUM(S.SaleAmount) > 200 



/*
WHEN TO USE AUTOCOMMIT TRANSACTIONS:	
	1. FOR DATA RETREIVAL  (SELECT)
	2. FOR DDL OPERATIONS  (CREATE, ALTER, DROP)
	3. FOR UNCONDITIONAL DML OPERATIONS   [EX: DATA IMPORT]


WHEN TO USE EXPLICIT / IMPLICIT TRANSACTIONS:	
	1. CONDITIONAL DML OPERATIONS	 (INSERT, UPDATE, DELETE)
	2. COMPLEX CODING SCENERIOS : PAYMENT GATEWAYS, ONLINE RESERVATIONS...
*/

