CREATE DATABASE  DB_CTE_USECASE
GO

USE DB_CTE_USECASE
GO

CREATE TABLE tblScopeIdentity
(
ID_COL INT identity(1000001,1),
Value_Col INT default 100,
RANK_Col INT
)

INSERT INTO tblScopeIdentity DEFAULT VALUES
INSERT INTO tblScopeIdentity DEFAULT VALUES
INSERT INTO tblScopeIdentity DEFAULT VALUES
INSERT INTO tblScopeIdentity DEFAULT VALUES
INSERT INTO tblScopeIdentity DEFAULT VALUES
INSERT INTO tblScopeIdentity DEFAULT VALUES
INSERT INTO tblScopeIdentity DEFAULT VALUES

SELECT * FROM tblScopeIdentity


-- REQUIREMENT : HOW TO STORE THE QUERY AND ITS RESULT IN MEMORY?
-- SOLUTION : CTE [COMMON TABLE EXPRESSION]. 
-- CTEs ARE A MECHANISM TO STORE THE QUERY & ITS RESULT IN MEMORY. TEMPORARY. BATCH LEVEL.
-- APPLICABLE FOR FASTER ACCESS TO DATA FOR QUICK COMPARISONS AND RECURSIVE OPERATIONS [SELF JOINS, SUB QUERIES]

-- THIS MEANS, IN REAL-WORLD  : THE CTEs CAN BE USED TO AVOID SELF JOINS AND SUB QUERIES. 

/*
SYNTAX:

WITH CTE
AS
(
SELECT QUERY
)
ATLEAST ONE OPERATION ON THE CTE
*/


-- EXAMPLE 1:  HOW TO DEFINE CTEs 
WITH CTE
AS
(
SELECT * FROM tblScopeIdentity
)
SELECT * FROM CTE


-- EXAMPLE 2:  HOW TO USE CTEs FOR DATA INSERTS ?
WITH CTE
AS
(
SELECT * FROM tblScopeIdentity
)
INSERT INTO CTE DEFAULT VALUES

-- VERIFY ABOVE INSERT IN THE BASE TABLE?
SELECT * FROM tblScopeIdentity


-- EXAMPLE #3: A REAL-LIFE SCENARIO TO USE CTEs. 
-- HOW TO AVOID SELF JOINS AND SUB QUERIES USING CTEs ?

-- REQUIREMENT :  IN THE GIVEN TABLE, WE HAVE 3 COLUMNS. 3RD COLUMN [RANK] HAS ALL NULL VALUES.
-- REQUIREMENT IS TO UPDATE THE RANK COLUMN WITH A UNIQUE SEQUENCE VALUES. EXAMPLE: 1,2,3,4.....

-- PHASE 1 : HOW TO REPORT SEQUENCE OF NUMBERS ?
SELECT *, ROW_NUMBER() OVER (ORDER BY ID_COL) AS SEQUENCE_NUMBER FROM tblScopeIdentity

-- PHASE 2: PROPOSED SOLUTION : unconditional update
UPDATE tblScopeIdentity
SET RANK_Col = SubQuery.SEQUENCE_NUMBER
FROM
(
SELECT *, ROW_NUMBER() OVER (ORDER BY ID_COL) AS SEQUENCE_NUMBER FROM tblScopeIdentity
) as SubQuery

SELECT * FROM tblScopeIdentity

-- PHASE 3: PROPOSED SOLUTION :  conditional update
UPDATE tblScopeIdentity
SET RANK_Col = SubQuery.SEQUENCE_NUMBER
FROM
(
SELECT *, ROW_NUMBER() OVER (ORDER BY ID_COL) AS SEQUENCE_NUMBER FROM tblScopeIdentity
) as SubQuery
INNER JOIN				-- SELF JOIN
tblScopeIdentity
ON
SubQuery.ID_COL = tblScopeIdentity.ID_COL 
AND
SubQuery.Value_Col = tblScopeIdentity.Value_Col


-- VERIFY ABOVE SOLUTION:
SELECT * FROM tblScopeIdentity

-- RESET THE DATA
UPDATE tblScopeIdentity SET RANK_Col = NULL 
SELECT * FROM tblScopeIdentity


-- PHASE 4: FINAL SOLUTION WITH CTEs TO AVOID SELF JOINS AND SUB QUERIES:
WITH RankUpdateQuery
AS
(
SELECT *, ROW_NUMBER() OVER (ORDER BY ID_COL) AS SEQUENCE_NUMBER FROM tblScopeIdentity
)
UPDATE RankUpdateQuery SET RANK_COL = SEQUENCE_NUMBER

-- VERIFY ABOVE OPTIMAL SOLUTION
SELECT * FROM tblScopeIdentity