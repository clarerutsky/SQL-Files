
CREATE DATABASE TESTDB11    
GO
USE TESTDB11


-- 1. INTEGER DATA TYPES:
CREATE TABLE TEST_TABLE1
(
COL1 BIGINT,				-- REQUIRES 8 BYTES STORAGE PER VALUE; RANGE: -9,223,372,036,854,770,000	to	9,223,372,036,854,770,000
COL2 INT,					-- REQUIRES 4 BYTES STORAGE PER VALUE; RANGE: -2,147,483,648				to	2,147,483,647
COL3 SMALLINT,				-- REQUIRES 2 BYTES STORAGE PER VALUE; RANGE: -32,768						to  32,767	
COL4 TINYINT				-- REQUIRES 1 BYTES STORAGE PER VALUE; RANGE: 0								TO  255
)

INSERT INTO TEST_TABLE1 VALUES (1000001, 20000, 1200, 255) 
INSERT INTO TEST_TABLE1 VALUES (1000001, 20000, 1200, 259) -- ERROR

 
-- 2. DECIMAL DATA TYPES:
CREATE TABLE TEST_TABLE2
(
COL1 DECIMAL (3, 2),		-- (S, P).	S: SCALE [TOTAL DIGITS]		P : PRECISION  [DIGITS AFTER DECIMAL]	Ex: 5.99
COL2 FLOAT (10),			-- Used for decimal values with a given precision number. Ex: Upto 10 decimals. Max Limit: 53
COL3 REAL					-- Used for decimal values with unlimitted precision numbers. Faster Computations.
)


-- 3. CHARACTER DATA TYPES:
CREATE TABLE TEST_TABLE3
(
COL1 CHAR(10),				-- REQUIRES 1 BYTE PER CHARACTER. THIS COLUMN CAN STORE UPTO 10 CHARACTERS; RESERVES EXACTLY 10 BYTES SPACE. 
COL2 VARCHAR(10),			-- REQUIRES 1 BYTE PER CHARACTER. THIS COLUMN CAN STORE UPTO 10 CHARACTERS; RESERVES UPTO 10 BYTES SPACE.			*

COL4 NCHAR(20),				-- REQUIRES 2 BYTES PER CHARACTER. THIS COLUMN CAN STORE UPTO 20 CHARACTERS; RESERVES EXACTLY 40 BYTES SPACE.
COL3 NVARCHAR(20),			-- REQUIRES 2 BYTS PER CHARACTER.  THIS COLUMN CAN STORE UPTO 20 CHARACTERS; RESERVES UPTO 40 BYTES SPACE.			*
 
COL5 VARCHAR(MAX),			-- REQUIRES 1 BYTE PER CHARACTER. THIS COLUMN CAN STORE UPTO 2 GB DATA; RESERVES UPTO 2 GB SPACE.					*
COL6 NVARCHAR(MAX),			-- REQUIRES 2 BYTES PER CHARACTER. THIS COLUMN CAN STORE UPTO 1 GB DATA; RESERVES UPTO 2 GB SPACE.
)

-- N MEANS UNICODE DATA. UNIVERSALLY CODED DECIMAL EXCHANGE CODE. STORES ANY LANGUAGE DATA.  DYNAMIC SQL, PASSWORD STORAGE, ETC.. 


-- 4. BINARY DATA TYPES:
CREATE TABLE TEST_TABLE4
(
COL1 BIT,				-- ZERO IS STORED AS 0. ANY NON ZERO VALUE IS STORED AS 1. 	
COL2 BINARY				-- STORES BINARY VALUE OF ANY NUMERICAL DATA IN HEXADECIMAL FORMAT. USEFUL FOR BLOB DATA [BINARY LARGE OBJECT DATA].
)

INSERT INTO TEST_TABLE4 VALUES (1, 1)
INSERT INTO TEST_TABLE4 VALUES (9, 9)
INSERT INTO TEST_TABLE4 VALUES (88, 99)
INSERT INTO TEST_TABLE4 VALUES (0, 99)

SELECT * FROM TEST_TABLE4



-- 5. TIMESTAMP DATA TYPES :
-- REAL-TIME USE: TO IDENTIFY THE ROWS IN OLTP & DWH FOR EASY COMPARISON. WE CALL THEM AS "WATERMARK" COLUMNS.
CREATE TABLE ExampleTable2 (COL1 DATETIME DEFAULT GETDATE()) ;
INSERT INTO ExampleTable2 DEFAULT VALUES 
INSERT INTO ExampleTable2 DEFAULT VALUES 
INSERT INTO ExampleTable2 DEFAULT VALUES 
SELECT * FROM ExampleTable2



-- 6. SQL_VARIANT	:	THIS DATA TYPE IS USED FOR ANY COLUMN IF WE ARE NOT SURE OF THE ACTUAL TYPE OF VALUE.
-- APPLICABLE FOR REAL-TIME, DYNAMIC DATA : ANY FORMAT, ANY SIZE.
CREATE TABLE ExampleTable5 (COL1 SQL_VARIANT) 

INSERT INTO ExampleTable5 VALUES (1)
INSERT INTO ExampleTable5 VALUES (1001)
INSERT INTO ExampleTable5 VALUES ('A')
INSERT INTO ExampleTable5 VALUES (5.9)
INSERT INTO ExampleTable5 VALUES ('2019-12-12')

SELECT * FROM ExampleTable5;




/*
CURSOR : A SPECIAL DATA TYPE. USED TO STORE DATA INSIDE MEMORY TEMPORARILY.
	
PURPOSE OF CURSOR:
	USED TO ACCESS THE DATA ON A ROW BY ROW BASIS.
	EXAMPLE: WE CAN ACCESS 4TH ROW OF THE TABLE USING CURSORS.


LIFECYCLE OF A CURSOR:
	STEP 1:		DECLARE CURSOR			:	TO DEFINE A CURSOR VARIABLE (A temporary Memory Space to store value)

	STEP 2:		OPEN CURSOR				:	TO LOAD THE TABLE DATA / QUERY RESULT INTO CURSOR MEMORY
	STEP 3:		FETCH OR SCROLL CURSOR	:	TO READ DATA FROM THE CURSOR. ONE ROW AT A TIME. 
	STEP 4:		CLOSE CURSOR			:	TO UNLOAD OR CLEAR THE DATA / QUERY RESULT FROM CURSOR MEMORY

	STEP 5:		DEALLOCATE CURSOR		:	TO DESTROY OR DROP THE CURSOR VARIABLE FROM MEMORY
*/

-- REALTIME USE OF CURSOR:	TO ACCESS nTH ROW OF A TABLE?  EX: HOW TO ACCESS 4TH ROW OF A TABLE?
	
use tempdb

CREATE TABLE tbltest
(
ID INT,
Value INT,
RANK INT
)

INSERT INTO tbltest VALUES(1,11,NULL)	INSERT INTO tbltest VALUES(2,22,NULL)
INSERT INTO tbltest VALUES(3,33,NULL)	INSERT INTO tbltest VALUES(4,33,NULL)
INSERT INTO tbltest VALUES(5,44,NULL)	INSERT INTO tbltest VALUES(6,44,NULL)
INSERT INTO tbltest VALUES(7,55,NULL)	INSERT INTO tbltest VALUES(8,55,NULL)
INSERT INTO tbltest VALUES(9,55,NULL)	INSERT INTO tbltest VALUES(10,55,NULL)

SELECT * FROM tbltest


-- EXAMPLE #1:	BASIC OPERATIONS WITH CURSOR
DECLARE CRS CURSOR 
FOR 
SELECT * FROM tbltest  

OPEN CRS					-- TO ENABLE THE CONNECTIONS TO THE CURSOR

FETCH NEXT FROM CRS			-- TO FETCH (REPORT) 1ST ROW FROM THE CURSOR
FETCH NEXT FROM CRS			-- TO FETCH (REPORT) NEXT ROW FROM THE CURSOR
FETCH NEXT FROM CRS			-- TO FETCH (REPORT) NEXT ROW FROM THE CURSOR
FETCH NEXT FROM CRS			-- TO FETCH (REPORT) NEXT ROW FROM THE CURSOR
	
CLOSE CRS					-- TO CLOSE THE CONNECTIONS FROM ACCESING THE CURSOR
DEALLOCATE CRS				-- TO DROP CURSOR VARIABLE FROM MEMORY.


-- EXAMPLE #2: HOW TO ACCESS 4TH ROW OF A TABLE?
DECLARE CRS CURSOR 
SCROLL						-- TO JUMP TO ANY ROW OF THE TABLE. FIRST, LAST, PRIOR, 4TH ROW...
FOR 
SELECT * FROM tbltest  

OPEN CRS					-- TO ENABLE THE CONNECTIONS TO THE CURSOR

FETCH ABSOLUTE 4 FROM CRS	-- THIS IS TO FETCH (REPORT) 4TH ROW FROM THE CURSOR  
FETCH ABSOLUTE 3 FROM CRS	-- THIS IS TO FETCH (REPORT) 4TH ROW FROM THE CURSOR  
FETCH LAST FROM CRS
FETCH PRIOR FROM CRS
FETCH NEXT FROM CRS
FETCH FIRST FROM CRS

CLOSE CRS					-- TO CLOSE THE CONNECTIONS FROM ACCESING THE CURSOR
DEALLOCATE CRS				-- TO REMOVE CURSOR DATA FROM MEMORY.



-- EXAMPLE #3: HOW TO ACCESS 4TH ROW OF A TABLE?
DECLARE CRS CURSOR 
FORWARD_ONLY						-- WE CAN ACCESS ONLY "NEXT" ROW IN THE CURSOR
DYNAMIC								-- CURSOR CAN ACCESS / SEE UPTO DATE CONTENT FROM THE BASE TABLE
GLOBAL								-- CURSOR IS ACCESSIBLE ACROSS THE BATCHES. 
FOR 
SELECT ID, VALUE FROM tbltest  WHERE ID > 100

OPEN CRS					-- TO ENABLE THE CONNECTIONS TO THE CURSOR

FETCH NEXT FROM CRS
FETCH NEXT FROM CRS
FETCH NEXT FROM CRS
FETCH NEXT FROM CRS
FETCH NEXT FROM CRS

CLOSE CRS					-- TO CLOSE THE CONNECTIONS FROM ACCESING THE CURSOR
DEALLOCATE CRS				-- TO REMOVE CURSOR DATA FROM MEMORY.





 